<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6-Move Chess Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            max-width: 600px; /* Max size for large screens */
            aspect-ratio: 1 / 1;
            border: 2px solid #4a5568; /* gray-700 */
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(20px, 8vw, 48px);
            user-select: none;
        }
        .light { background-color: #f0d9b5; }
        .dark { background-color: #b58863; }
        .selected { background-color: #6b7280 !important; /* gray-500 */ }
        .possible-move::after {
            content: '';
            display: block;
            width: 30%;
            height: 30%;
            border-radius: 50%;
            background-color: rgba(107, 114, 128, 0.5); /* gray-500 with opacity */
        }
        .piece { cursor: pointer; }
        .piece.black { color: #1f2937; } /* gray-800 */
        .piece.white { color: #f9fafb; } /* gray-50 */

        /* Modal Styles */
        .modal {
            transition: opacity 0.25s ease;
        }
        .modal-content {
            transition: transform 0.25s ease;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl mx-auto flex flex-col lg:flex-row gap-8">
        
        <!-- Game Board and Info -->
        <div class="flex-grow flex flex-col items-center">
            <h1 class="text-3xl font-bold mb-2 text-center">6-Move Chess Challenge</h1>
            <div id="game-status" class="h-8 mb-2 text-xl font-semibold text-yellow-300">White's Turn</div>
            
            <div id="chess-board" class="chess-board shadow-2xl"></div>

            <div class="w-full mt-4 flex justify-center">
                <button id="new-game-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105">
                    Setup New Game
                </button>
            </div>
        </div>

        <!-- Game State & Rules -->
        <div class="w-full lg:w-80 flex-shrink-0 bg-gray-800 p-6 rounded-lg shadow-xl">
            <h2 class="text-2xl font-bold border-b-2 border-gray-600 pb-2 mb-4">Game Info</h2>
            
            <div class="space-y-4">
                <div>
                    <h3 class="text-lg font-semibold">Moves Remaining</h3>
                    <div class="flex justify-between bg-gray-700 p-3 rounded-lg">
                        <span>White: <strong id="white-moves" class="text-2xl">6</strong></span>
                        <span>Black: <strong id="black-moves" class="text-2xl">6</strong></span>
                    </div>
                </div>

                <div>
                    <h3 class="text-lg font-semibold">Points</h3>
                    <div class="flex justify-between bg-gray-700 p-3 rounded-lg">
                        <span>White: <strong id="white-score" class="text-2xl">0</strong></span>
                        <span>Black: <strong id="black-score" class="text-2xl">0</strong></span>
                    </div>
                </div>

                <div>
                    <h3 class="text-lg font-semibold">Last Move</h3>
                    <div id="last-move" class="bg-gray-700 p-3 rounded-lg h-12 font-mono">--</div>
                </div>
            </div>

            <div class="mt-6 pt-4 border-t border-gray-600">
                <h3 class="text-lg font-bold mb-2">Points System</h3>
                <ul class="text-sm space-y-1 text-gray-300">
                    <li><strong>Checkmate:</strong> Instant Win</li>
                    <li><strong>Queen:</strong> 9 points</li>
                    <li><strong>Rook:</strong> 5 points</li>
                    <li><strong>Bishop/Knight:</strong> 3 points</li>
                    <li><strong>Pawn:</strong> 1 point</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Board Setup Modal -->
    <div id="setup-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 opacity-0 pointer-events-none">
        <div id="modal-content" class="bg-gray-800 rounded-2xl shadow-2xl p-8 w-full max-w-4xl transform scale-95">
            <h2 class="text-3xl font-bold text-center mb-6">Setup Your Board</h2>
            
            <div class="flex flex-col md:flex-row gap-6">
                <!-- Setup Board -->
                <div class="flex-grow">
                    <div id="setup-board" class="chess-board border-gray-600"></div>
                </div>

                <!-- Piece Palette & Controls -->
                <div class="w-full md:w-56 flex-shrink-0">
                    <h3 class="text-xl font-semibold mb-3">Select a Piece</h3>
                    <div id="piece-palette" class="grid grid-cols-4 gap-2 bg-gray-700 p-3 rounded-lg">
                        <!-- Pieces will be injected here by JS -->
                    </div>

                    <div id="selected-piece-display" class="mt-4 text-center bg-gray-900 p-2 rounded-lg">
                        Selected: <span id="current-piece" class="text-2xl">None</span>
                    </div>
                    
                    <div class="mt-6 space-y-3">
                        <button id="start-game-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105">Start Game</button>
                        <button id="clear-board-btn" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg">Clear Board</button>
                        <button id="reset-standard-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Standard Position</button>
                        <button id="cancel-setup-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg mt-4">Cancel</button>
                    </div>
                </div>
            </div>
             <p class="text-center text-gray-400 mt-4 text-sm">Instructions: Select a piece from the palette, then click on the board to place it. Click an empty square in the palette to select the eraser. You must place both a white and a black king.</p>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const boardElement = document.getElementById('chess-board');
        const setupBoardElement = document.getElementById('setup-board');
        const gameStatusElement = document.getElementById('game-status');
        const whiteMovesElement = document.getElementById('white-moves');
        const blackMovesElement = document.getElementById('black-moves');
        const whiteScoreElement = document.getElementById('white-score');
        const blackScoreElement = document.getElementById('black-score');
        const lastMoveElement = document.getElementById('last-move');
        const newGameBtn = document.getElementById('new-game-btn');
        
        // Modal elements
        const setupModal = document.getElementById('setup-modal');
        const modalContent = document.getElementById('modal-content');
        const piecePalette = document.getElementById('piece-palette');
        const selectedPieceDisplay = document.getElementById('current-piece');
        const startGameBtn = document.getElementById('start-game-btn');
        const clearBoardBtn = document.getElementById('clear-board-btn');
        const resetStandardBtn = document.getElementById('reset-standard-btn');
        const cancelSetupBtn = document.getElementById('cancel-setup-btn');

        // --- Game State ---
        let chess = new Chess();
        let selectedSquare = null;
        let whiteMoves = 6;
        let blackMoves = 6;
        let whiteScore = 0;
        let blackScore = 0;
        let gameOver = true;

        // --- Setup State ---
        let setupBoardState = {}; // Using an object: 'e4': 'wP'
        let selectedPalettePiece = null;

        // --- Constants ---
        const PIECE_VALUES = { 'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9 };
        const PIECE_UNICODE = {
            'wP': '♙', 'wN': '♘', 'wB': '♗', 'wR': '♖', 'wQ': '♕', 'wK': '♔',
            'bP': '♟', 'bN': '♞', 'bB': '♝', 'bR': '♜', 'bQ': '♛', 'bK': '♚'
        };
        const PALETTE_PIECES = [
            'wK', 'wQ', 'wR', 'wB', 'wN', 'wP',
            'bK', 'bQ', 'bR', 'bB', 'bN', 'bP'
        ];

        // --- Chess Logic ---

        /**
         * Renders the main chessboard based on the current chess.js state.
         */
        function renderBoard() {
            boardElement.innerHTML = '';
            const board = chess.board();
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.createElement('div');
                    const squareName = 'abcdefgh'[j] + (8 - i);
                    square.id = squareName;
                    square.className = `square ${(i + j) % 2 === 0 ? 'light' : 'dark'}`;
                    
                    const piece = board[i][j];
                    if (piece) {
                        const pieceElement = document.createElement('span');
                        pieceElement.className = `piece ${piece.color === 'w' ? 'white' : 'black'}`;
                        pieceElement.innerText = PIECE_UNICODE[piece.color + piece.type.toUpperCase()];
                        square.appendChild(pieceElement);
                    }

                    square.addEventListener('click', () => onSquareClick(squareName));
                    boardElement.appendChild(square);
                }
            }

            if (selectedSquare) {
                document.getElementById(selectedSquare)?.classList.add('selected');
                highlightPossibleMoves(selectedSquare);
            }
        }

        /**
         * Handles clicks on the main game board.
         * @param {string} squareName - The name of the clicked square (e.g., 'e4').
         */
        function onSquareClick(squareName) {
            if (gameOver || chess.turn() !== 'w') return;

            if (selectedSquare) {
                // This is the second click (the 'to' square)
                const move = {
                    from: selectedSquare,
                    to: squareName,
                    promotion: 'q' // Always promote to queen for simplicity
                };

                const result = chess.move(move);
                if (result) {
                    handleMove(result);
                }
                
                // Reset selection regardless of move success
                selectedSquare = null;
                renderBoard();

            } else {
                // This is the first click (the 'from' square)
                const piece = chess.get(squareName);
                if (piece && piece.color === 'w') {
                    selectedSquare = squareName;
                    renderBoard();
                }
            }
        }
        
        /**
         * Processes a move, updates state, and triggers the AI.
         * @param {object} move - The move object from chess.js.
         */
        function handleMove(move) {
            updateScore(move);
            updateMovesCount();
            lastMoveElement.textContent = move.san;
            renderBoard();
            updateGameStatus();

            if (!gameOver) {
                // AI's turn
                window.setTimeout(makeAIMove, 500);
            }
        }
        
        /**
         * Highlights all legal moves for a selected piece.
         * @param {string} fromSquare - The square of the piece to show moves for.
         */
        function highlightPossibleMoves(fromSquare) {
            const moves = chess.moves({ square: fromSquare, verbose: true });
            moves.forEach(move => {
                document.getElementById(move.to)?.classList.add('possible-move');
            });
        }

        /**
         * A simple AI to make a move for Black.
         * It prioritizes captures, then checks, then random moves.
         */
        function makeAIMove() {
            if (gameOver || chess.turn() !== 'b') return;
            
            const moves = chess.moves({ verbose: true });
            if (moves.length === 0) return;

            let bestMove = null;
            let bestScore = -Infinity;

            // Simple evaluation: capture > check > random
            for (const move of moves) {
                let score = 0;
                if (move.flags.includes('c')) score += 10 * (PIECE_VALUES[move.captured] || 1);
                if (move.san.includes('+')) score += 1;
                if (move.san.includes('#')) score += 1000;
                
                if(score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            
            // If no special move, pick one at random
            if (!bestMove) {
                bestMove = moves[Math.floor(Math.random() * moves.length)];
            }

            const result = chess.move(bestMove.san);
            if(result) {
                updateScore(result);
                updateMovesCount();
                lastMoveElement.textContent = result.san;
                renderBoard();
                updateGameStatus();
            }
        }

        /**
         * Updates the score based on a captured piece.
         * @param {object} move - The move object from chess.js.
         */
        function updateScore(move) {
            if (move.captured) {
                const pieceValue = PIECE_VALUES[move.captured];
                if (move.color === 'w') {
                    whiteScore += pieceValue;
                    whiteScoreElement.textContent = whiteScore;
                } else {
                    blackScore += pieceValue;
                    blackScoreElement.textContent = blackScore;
                }
            }
        }

        /**
         * Updates the remaining moves count.
         */
        function updateMovesCount() {
            if (chess.turn() === 'b') { // White just moved
                whiteMoves--;
                whiteMovesElement.textContent = whiteMoves;
            } else { // Black just moved
                blackMoves--;
                blackMovesElement.textContent = blackMoves;
            }
        }

        /**
         * Checks and updates the game's status (ongoing, checkmate, draw, etc.).
         */
        function updateGameStatus() {
            let status = '';
            if (chess.in_checkmate()) {
                status = `Checkmate! ${chess.turn() === 'w' ? 'Black' : 'White'} wins.`;
                gameOver = true;
            } else if (chess.in_draw() || chess.in_stalemate() || chess.in_threefold_repetition()) {
                status = 'Game over: Draw.';
                gameOver = true;
            } else if (whiteMoves === 0 && blackMoves === 0) {
                 gameOver = true;
                 if (whiteScore > blackScore) status = "Game Over! White wins on points.";
                 else if (blackScore > whiteScore) status = "Game Over! Black wins on points.";
                 else status = "Game Over! It's a draw on points.";
            } else {
                status = `${chess.turn() === 'w' ? 'White' : 'Black'}'s Turn`;
                if(chess.in_check()) {
                    status += ' (Check)';
                }
            }
            gameStatusElement.textContent = status;
        }

        /**
         * Resets the game to its initial state.
         * @param {string} [fen] - An optional FEN string to start the game from.
         */
        function resetGame(fen) {
            chess = fen ? new Chess(fen) : new Chess();
            selectedSquare = null;
            whiteMoves = 6;
            blackMoves = 6;
            whiteScore = 0;
            blackScore = 0;
            gameOver = false;

            whiteMovesElement.textContent = whiteMoves;
            blackMovesElement.textContent = blackMoves;
            whiteScoreElement.textContent = whiteScore;
            blackScoreElement.textContent = blackScore;
            lastMoveElement.textContent = '--';
            
            renderBoard();
            updateGameStatus();
            if (chess.turn() === 'b' && !gameOver) {
                window.setTimeout(makeAIMove, 500);
            }
        }

        // --- Board Setup Logic ---

        /**
         * Initializes and shows the board setup modal.
         */
        function showSetupModal() {
            initPalette();
            renderSetupBoard();
            setupModal.classList.remove('opacity-0', 'pointer-events-none');
            modalContent.classList.remove('scale-95');
        }

        /**
         * Hides the board setup modal.
         */
        function hideSetupModal() {
            setupModal.classList.add('opacity-0', 'pointer-events-none');
            modalContent.classList.add('scale-95');
        }

        /**
         * Creates the piece selection palette.
         */
        function initPalette() {
            piecePalette.innerHTML = '';
            // Add an empty square for erasing
            const eraser = document.createElement('div');
            eraser.className = 'square light cursor-pointer flex items-center justify-center text-red-500 text-3xl';
            eraser.innerHTML = '×';
            eraser.addEventListener('click', () => selectPalettePiece(null));
            piecePalette.appendChild(eraser);

            PALETTE_PIECES.forEach(pieceKey => {
                const pieceDiv = document.createElement('div');
                pieceDiv.className = 'square dark cursor-pointer';
                pieceDiv.innerHTML = `<span class="piece ${pieceKey.startsWith('w') ? 'white' : 'black'}">${PIECE_UNICODE[pieceKey]}</span>`;
                pieceDiv.addEventListener('click', () => selectPalettePiece(pieceKey));
                piecePalette.appendChild(pieceDiv);
            });
        }

        /**
         * Renders the setup board based on the `setupBoardState`.
         */
        function renderSetupBoard() {
            setupBoardElement.innerHTML = '';
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.createElement('div');
                    const squareName = 'abcdefgh'[j] + (8 - i);
                    square.className = `square ${(i + j) % 2 === 0 ? 'light' : 'dark'} cursor-pointer`;
                    
                    if (setupBoardState[squareName]) {
                        const pieceKey = setupBoardState[squareName];
                        square.innerHTML = `<span class="piece ${pieceKey.startsWith('w') ? 'white' : 'black'}">${PIECE_UNICODE[pieceKey]}</span>`;
                    }

                    square.addEventListener('click', () => onSetupSquareClick(squareName));
                    setupBoardElement.appendChild(square);
                }
            }
        }

        /**
         * Handles selecting a piece from the palette.
         * @param {string | null} pieceKey - The key of the selected piece (e.g., 'wP') or null for eraser.
         */
        function selectPalettePiece(pieceKey) {
            selectedPalettePiece = pieceKey;
            if (pieceKey) {
                selectedPieceDisplay.innerHTML = `<span class="piece ${pieceKey.startsWith('w') ? 'white' : 'black'}">${PIECE_UNICODE[pieceKey]}</span>`;
            } else {
                selectedPieceDisplay.innerHTML = '<span class="text-red-500">Eraser</span>';
            }
        }

        /**
         * Handles clicking a square on the setup board to place/remove a piece.
         * @param {string} squareName - The name of the clicked square.
         */
        function onSetupSquareClick(squareName) {
            if (selectedPalettePiece) {
                setupBoardState[squareName] = selectedPalettePiece;
            } else {
                delete setupBoardState[squareName];
            }
            renderSetupBoard();
        }

        /**
         * Converts the setup board state into a FEN string.
         * @returns {string | null} The generated FEN string or null if invalid.
         */
        function generateFenFromSetup() {
            let fen = '';
            let whiteKing = false;
            let blackKing = false;

            for (let i = 8; i >= 1; i--) {
                let emptyCount = 0;
                for (let j = 0; j < 8; j++) {
                    const file = 'abcdefgh'[j];
                    const squareName = file + i;
                    const pieceKey = setupBoardState[squareName];

                    if (pieceKey) {
                        if (emptyCount > 0) {
                            fen += emptyCount;
                            emptyCount = 0;
                        }
                        const color = pieceKey[0];
                        const type = pieceKey[1];
                        fen += color === 'w' ? type.toUpperCase() : type.toLowerCase();
                        if (type === 'K') {
                            if (color === 'w') whiteKing = true;
                            else blackKing = true;
                        }
                    } else {
                        emptyCount++;
                    }
                }
                if (emptyCount > 0) {
                    fen += emptyCount;
                }
                if (i > 1) {
                    fen += '/';
                }
            }

            if (!whiteKing || !blackKing) {
                alert("Invalid position: Both a white and a black king must be on the board.");
                return null;
            }

            // For this game, we assume white to move and no castling rights.
            fen += ' w - - 0 1';
            return fen;
        }

        // --- Event Listeners ---
        newGameBtn.addEventListener('click', showSetupModal);
        cancelSetupBtn.addEventListener('click', hideSetupModal);

        clearBoardBtn.addEventListener('click', () => {
            setupBoardState = {};
            renderSetupBoard();
        });

        resetStandardBtn.addEventListener('click', () => {
            const standardChess = new Chess();
            setupBoardState = {};
            standardChess.board().forEach((row, rowIndex) => {
                row.forEach((piece, colIndex) => {
                    if (piece) {
                        const squareName = 'abcdefgh'[colIndex] + (8 - rowIndex);
                        setupBoardState[squareName] = piece.color + piece.type.toUpperCase();
                    }
                });
            });
            renderSetupBoard();
        });

        startGameBtn.addEventListener('click', () => {
            const fen = generateFenFromSetup();
            if (fen) {
                hideSetupModal();
                resetGame(fen);
            }
        });

        // --- Initial Load ---
        renderBoard(); // Render the initial empty or default board
        gameStatusElement.textContent = 'Click "Setup New Game" to begin!';

    </script>
</body>
</html>
